"""
Based repositorie
"""

import inspect
from typing import TypeVar, Generic, List, get_origin, get_args, Type

from sqlalchemy.ext.asyncio import AsyncSession
from sqlmodel import SQLModel, select


T = TypeVar("T", bound=SQLModel)

class BaseRepo(Generic[T]):
    """
    Base repositorie
    """

    def __init__(self, session: AsyncSession):
        self.session = session
        self.model = self._get_model_class()

    def _get_model_class(self) -> Type[T]:
        """
        Extrai dinamicamente a classe do modelo a partir do Generic T
        """
        # Método 1: Verificar __orig_bases__ se existir
        if hasattr(self.__class__, '__orig_bases__'):
            for base in self.__class__.__orig_bases__:
                if get_origin(base) and get_origin(base) is not Generic:
                    args = get_args(base)
                    if args and len(args) > 0:
                        model_class = args[0]
                        if inspect.isclass(model_class) and issubclass(model_class, SQLModel):
                            return model_class

        # Método 2: Verificar __parameters__ e __args__ 
        for base in self.__class__.__mro__:
            if hasattr(base, '__parameters__') and hasattr(base, '__args__'):
                if base.__args__:
                    model_class = base.__args__[0]
                    if inspect.isclass(model_class) and issubclass(model_class, SQLModel):
                        return model_class

        # Método 3: Verificar annotations da subclasse
        for cls in self.__class__.__mro__:
            if hasattr(cls, '__annotations__'):
                for _, annotation in cls.__annotations__.items():
                    if hasattr(annotation, '__origin__'):
                        args = get_args(annotation)
                        if args:
                            model_class = args[0]
                            if inspect.isclass(model_class) and issubclass(model_class, SQLModel):
                                return model_class

        raise ValueError(
            f"Não foi possível determinar o tipo do modelo para {self.__class__.__name__}. "
            "Forneça model_class explicitamente no construtor."
        )

    async def create(self, obj: T) -> T:
        """
        Create new entity from model.

        Args:
            obj (T): An instance of the model type T to be created.

        Returns:
            T: The created instance with updated fields (e.g., autogenerated ID).
        """
        self.session.add(obj)
        await self.session.commit()
        await self.session.refresh(obj)
        return obj

    async def get_by_id(self, id_obj: int, for_update: bool = False) -> T | None:
        """
        Get an entity by its ID.

        Args:
            id (int): The ID of the entity to retrieve.
    
        Returns:
            T: The entity with the specified ID.
        """
        stmt = select(self.model).where(self.model.id == id_obj)
        if for_update:
            stmt = stmt.with_for_update()

        result = await self.session.execute(stmt)
        return result.scalars().one()

    async def get_all(self) -> List[T]:
        """
        Get all entities of the model type.

        Returns:
            List[T]: A list of all entities of the model type.
        """

        result = await self.session.execute(select(self.model))
        return result.scalars().all()

    async def update(self, obj: T) -> T:
        """
        Update an entity.

        Args:
            obj (T): An instance of the model type T to be updated.
        """
        obj = await self.session.merge(obj)
        await self.session.commit()
        await self.session.refresh(obj)
        return obj
